---
layout: post
title: "Array, Linked list, Stack, Queue"
description: ""
category: Programming
tags: [Programming, Algorithm, Stack]
---
{% include JB/setup %}

## Basic concepts

1. `Array` is a _random accres_ data structure (like a book) in which each element in the array can be accessed in constant time.
1. `Linked list` is a _sequential access_ data structure (like a tape) in which elements are accessible in particular order. One element can be accessed only if all prior elements are visited.

1. `Stack`

   1. `Stack` is a _limit access_ data structure that stores and processes the data according to '_first come last served_' policy.
   1. We usually talk about `Stack` by comparing it to `Queue` which implements according to '_first come first served_' policy.
   1. Operations with `Stack`
      1. `push()`, push an element on top of the stack
      1. `pop()`, remove an element from top of the stack
      1. `top()`, get an element from top of the stack
      1. `empty()`, check if the stack is empty
   1. `Stack` can be implemented with `Array`, `Linked list`, or `Queue`.

1. `Queue`

   1. `Queue` is a _limit access_ data structure that implements a `_first come first served_` principle.
   1. Operation with `Queue`
      1. `push()`, push an element to the tail of the queue
      1. `pop()`, remove an element from the top of the queue
      1. `peek()`, get an element from the top of the queue
      1. `empty()`, check if the queue is empty
   1. `Queue` can be implemented with `Array`, `Linked list`, or `Stack`.

1. `Circular queue`

   1. `Circular queue` is a special queue where, e.g., 
      1. the queue is implemented with an array of fixed length
      1. keeping the index of first and last elements
      1. removing an element is by increasing the index of the first element
      1. adding an element is by inserting it into the next position of the last element
      1. wrap around with a modulo operation.

1. Additional reading materials

   1. [Lecture note about Stacks and Queues](http://www.cs.cmu.edu/~adamchik/15-121/lectures/Stacks%20and%20Queues/Stacks%20and%20Queues.html).

## Possible applications

1. Depth first search with `Stack`
1. Breath first search with `Queue`
1. Evaluate arithmetic operation with 'stack'
   1. Change infix expression into postfix expression with `Stack`
   1. Evaluate the postfix expression with `Stack`

## Related coding exercises

Here are some interesting/difficult problems from LeetCode related to `Stack`.

### [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)

1. Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
1. An example Python code is given as the following
{%highlight Python%}
class Solution:
    # @param {integer[]} height
    # @return {integer}
    def largestRectangleArea(self, height):
        return solution(height)
def solution(height):
    height = [0] + height + [0]
    stack = [0]
    rtn = 0
    for i,x in enumerate(height):
        while x<height[stack[-1]]:
            # do something
            j = stack.pop()
            h = height[j]
            w = i-stack[-1]-1
            rtn = max(rtn,w*h)
        stack.append(i)
    return rtn
    pass
{%endhighlight%}

### [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)
1. Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.
1. This problem can be reduced to [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) by summing up and analyze rows one by another with a subroutine that compute the largest rectangle in Histogram.
1. An example Python code is given as the following
{%highlight Python%}
class Solution:
    # @param {character[][]} matrix
    # @return {integer}
    def maximalRectangle(self, matrix):
        '''
        codeing 29
        '''
        if len(matrix) == 0: return 0
        # initialization
        m,n = len(matrix),len(matrix[0])
        row = [0]*n
        val = 0
        # 
        for i in xrange(m):
            for j in xrange(n):
                if matrix[i][j] == '1':
                    row[j] += 1
                else:
                    row[j] = 0
            curval = process_a_row(row)
            if curval > val:
                val = curval
        return val
def process_a_row(xs):
    xs = [0] + xs + [0]
    stack = [0]
    res = 0
    for i, x in enumerate(xs):
        while x < xs[stack[-1]]:
            y = xs[stack.pop()]
            res = max(res, (i-1-stack[-1])*y)
        stack.append(i)
    return res
{%endhighlight%}

